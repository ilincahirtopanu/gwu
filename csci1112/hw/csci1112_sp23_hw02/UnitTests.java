/*--------------------------------------------------------------------------
GWU CSCI 1112 Spring 2023
author: James Taylor

This program performs unit testing on the ClassSchedule class.  
--------------------------------------------------------------------------*/

public class UnitTests {
    // The master list of class data
    public static String[][] classes;

    // The referential views of classes generated by different sorts
    public static String[][] viewSelection;    // generated by selection sort
    public static String[][] viewBubble;       // generated by bubble sort
    public static String[][] viewInsertion;    // generated by insertion sort
    public static String[][] viewQuicksort;    // generated by quicksort

    // The profiling data gathered during a sort
    public static int[] profileSelection;   // profile from selection sort
    public static int[] profileBubble;      // profile from bubble sort
    public static int[] profileInsertion;   // profile from insertion sort
    public static int[] profileQuicksort;   // profile from quicksort

    // ---------------------------------------------------------------------
    // Entry Point
    // ---------------------------------------------------------------------
    /// Entry Point.  The main program executes a set of UnitTests on the 
    /// various methods in the ClassSchedule class to test different levels of 
    /// functionality.
    public static void main (String[] argv) {
        boolean status;

        // Using global variables here which is discouraged unless you 
        // understand exactly why.  In general, you should not follow this 
        // model unless you have very good reason.  The reason that it is 
        // acceptable here is that this is a test suite, the work is all 
        // done here in this file and function, and the test functions only
        // read the contents of the variables.  If most of this criteria is
        //  not met, then a global variable is likely a huge mistake.
        classes = ScheduleReader.getSchedule("classes.csv");
        viewSelection = ClassSchedule.createView(classes);
        viewBubble = ClassSchedule.createView(classes);
        viewInsertion = ClassSchedule.createView(classes);
        viewQuicksort = ClassSchedule.createView(classes);

        // -----------------------------------------------------------------
        // Block 1 Unit Tests
        // -----------------------------------------------------------------
        System.out.println("Block 1 Unit Tests");

        status = testFundamentals();
        if( status == false ) {
            System.out.println("testFundamentals() failed.  This set of tests must pass before any other tests are valid.  Other tests will be performed once this set of tests succeed.");
            return;
        }

        
        status = testClone();
        if( status == false ) {
            System.out.println("testClone() failed.");
            return;
        }

        System.out.println("Passed Block 1 Unit Testing\n");

        // -----------------------------------------------------------------
        // Block 2 Unit Tests
        // -----------------------------------------------------------------
        System.out.println("Block 2 Unit Tests");

        // perform iterative sorts
        profileSelection = ClassSchedule.sortSelection(viewSelection);
        profileBubble = ClassSchedule.sortBubble(viewBubble);
        profileInsertion = ClassSchedule.sortInsertion(viewInsertion);

        // validate iterative sorts
        status = testIterativeSorts();
        if( status == false ) {
            System.out.println("testIterativeSorts() failed.  At least one of the iterative sorts failed the set of unit tests.  Other tests will be performed once this set of tests succeed.");
            return;
        }

        System.out.println("Passed Block 2 Unit Testing\n");

        // -----------------------------------------------------------------
        // Block 3 Unit Tests
        // -----------------------------------------------------------------
        System.out.println("Block 3 Unit Tests");

        // perform Quicksort
        profileQuicksort = ClassSchedule.sortQuicksort(viewQuicksort);

        // validate Quicksort
        status = testQuicksort();
        if( status == false ) {
            System.out.println("testQuicksort() failed.");
            return;
        }

        System.out.println("Passed Block 3 Unit Testing\n");

        // -----------------------------------------------------------------
        // Block 4 Unit Tests
        // -----------------------------------------------------------------
        System.out.println("Block 4 Unit Tests");

        if( !testProfile( profileSelection, "profileSelection" ) ) {
            System.out.println("testProfile(profileSelection) failed.");
            return;
        }
        if( !testProfile( profileBubble, "profileBubble" ) ) {
            System.out.println("testProfile(profileBubble) failed.");
            return;
        }
        if( !testProfile( profileInsertion, "profileInsertion" ) ) {
            System.out.println("testProfile(profileInsertion) failed.");
            return;
        }
        if( !testProfile( profileQuicksort, "profileQuicksort" ) ) {
            System.out.println("testProfile(profileQuicksort) failed.");
            return;
        }

        System.out.println("Passed Block 4 Unit Testing\n");

        System.out.println("SUCCESS!  All tests passed.  Run ProfileSorts to view the performance profile information for each sort.");
    }


    // ---------------------------------------------------------------------
    /// A set of fundamental tests that have to pass before any other tests
    /// can be considered.
    /// @return true if all tests pass and other tests can proceed; 
    ///         otherwise, false
    public static boolean testFundamentals() {
        boolean passed = true;

        if( testDataLength() ) {
            System.out.println("testDataLength(initial) succeeded");
        } else {
            System.out.println("testDataLength(initial) failed");
            passed = false;
        }

        if( testDataOrder() ) {
            System.out.println("testDataOrder(initial) succeeded");
        } else {
            System.out.println("testDataOrder(initial) failed");
            passed = false;
        }

        if( testDifferential() ) {
            System.out.println("testDifferential succeeded");
        } else {
            System.out.println("testDifferential failed");
            passed = false;
        }

        if( testLessThan() ) {
            System.out.println("testLessThan succeeded");
        } else {
            System.out.println("testLessThan failed");
            passed = false;
        }

        if( testSwap() ) {
            System.out.println("testSwap succeeded");
        } else {
            System.out.println("testSwap failed");
            passed = false;
        }

        return passed;
    }

    // ---------------------------------------------------------------------
    /// Tests the clone function.
    /// @return Returns true if the function passes all defined tests; 
    ///         otherwise, returns false
    public static boolean testClone() {
        String[][] src; 
        String[][] dest; 

        src = classes;
        // deep copy from image in src to dest for the test
        dest = ClassSchedule.clone( src );

        // validate that neither source nor destination are null pointers
        if( src == null || dest == null ) {
            return false;
        }
        // validate that the images have the same size
        if( src.length != dest.length ) {
            return false;
        }
        // iterate over all source rows
        for (int i=0; i < src.length; i++) {
            // if any row pointer is the same in source and destination,
            // it is a shallow copy
            if( src[i] == dest[i] ) {
                return false;
            }
            // validate that this row in the source and destination are the 
            // same size
            if( src[i].length != dest[i].length ) {
                return false;
            }
            // iterate over each channel in the pixel and validate that the
            // channel in the src and the channel in the dest have the same
            // numeric value
            for (int j=0; j < src[i].length; j++) {
                if( src[i][j] != dest[i][j] ) {
                    return false;
                }
            }
        }
        // base assumption.  If we cannot disprove it is a deep copy, we assume
        // it is
        return true;
    }

    // ---------------------------------------------------------------------
    /// A set of tests on the iterative sorts that have to pass before any 
    /// other tests can be considered.
    /// @return true if all tests pass and other tests can proceed; 
    ///         otherwise, false
    public static boolean testIterativeSorts() {
        boolean passed = true;

        // --------------------------------------------------------------------
        if( testRowLevelCopy(classes, viewSelection, "viewSelection") ) {
            System.out.println("testRowLevelCopy(viewSelection) succeeded");
        } else {
            System.out.println("testRowLevelCopy(viewSelection) failed");
            passed = false;
        }

        if( testSort(viewSelection, "viewSelection" ) ) {
            System.out.println("testSort(viewSelection) succeeded");
        } else {
            System.out.println("testSort(viewSelection) failed");
            passed = false;
        }

        if( testDataLength() ) {
            System.out.println("testDataLength(after sortSelection) succeeded");
        } else {
            System.out.println("testDataLength(after sortSelection) failed");
            passed = false;
        }

        if( testDataOrder() ) {
            System.out.println("testDataOrder(after sortSelection) succeeded");
        } else {
            System.out.println("testDataOrder(after sortSelection) failed");
            passed = false;
        }

        // -----------------------------------------------------------------

        if( testRowLevelCopy(classes, viewBubble, "viewBubble") ) {
            System.out.println("testRowLevelCopy(viewBubble) succeeded");
        } else {
            System.out.println("testRowLevelCopy(viewBubble) failed");
            passed = false;
        }

        if( testSort(viewBubble, "viewBubble" ) ) {
            System.out.println("testSort(viewBubble) succeeded");
        } else {
            System.out.println("testSort(viewBubble) failed");
            passed = false;
        }

        if( testDataLength() ) {
            System.out.println("testDataLength(after sortBubble) succeeded");
        } else {
            System.out.println("testDataLength(after sortBubble) failed");
            passed = false;
        }

        if( testDataOrder() ) {
            System.out.println("testDataOrder(after sortBubble) succeeded");
        } else {
            System.out.println("testDataOrder(after sortBubble) failed");
            passed = false;
        }

        // -----------------------------------------------------------------

        if( testRowLevelCopy(classes, viewInsertion, "viewInsertion") ) {
            System.out.println("testRowLevelCopy(viewInsertion) succeeded");
        } else {
            System.out.println("testRowLevelCopy(viewInsertion) failed");
            passed = false;
        }

        if( testSort(viewInsertion, "viewInsertion" ) ) {
            System.out.println("testSort(viewInsertion) succeeded");
        } else {
            System.out.println("testSort(viewInsertion) failed");
            passed = false;
        }

        if( testDataLength() ) {
            System.out.println("testDataLength(after sortInsertion) succeeded");
        } else {
            System.out.println("testDataLength(after sortInsertion) failed");
            passed = false;
        }

        if( testDataOrder() ) {
            System.out.println("testDataOrder(after sortInsertion) succeeded");
        } else {
            System.out.println("testDataOrder(after sortInsertion) failed");
            passed = false;
        }

        // -----------------------------------------------------------------
        // This set of subtests compares the ordering of the result sets to
        // one another.  In most cases, this set of tests might be a bit
        // dangerous because we might have multiple entries that share the
        // same value for sort criteria and the order could therefore vary
        // depending on how you approach your algorithm, i.e. whether your
        // algorithm sweeps left to right vs. right to left.  This example
        // is gamed so that no differential can be equal so there is a clear
        // objective order.
        if( testCompareSorts(viewSelection, "viewSelection", viewBubble, "viewBubble") ) {
            System.out.println("testCompareSorts(viewSelection, viewBubble) succeeded");
        } else {
            System.out.println("testCompareSorts(viewSelection, viewBubble) failed");
            passed = false;
        }

        if( testCompareSorts(viewSelection, "viewSelection", viewInsertion, "viewInsertion") ) {
            System.out.println("testCompareSorts(viewSelection, viewInsertion) succeeded");
        } else {
            System.out.println("testCompareSorts(viewSelection, viewInsertion) failed");
            passed = false;
        }

        return passed;
    }

    // ---------------------------------------------------------------------
    /// A set of tests on quicksort that have to pass before any other tests
    /// can be considered.
    /// @return true if all tests pass and other tests can proceed; 
    ///         otherwise, false
    public static boolean testQuicksort() {
        boolean passed = true;

        if( testRowLevelCopy(classes, viewQuicksort, "viewQuicksort") ) {
            System.out.println("testRowLevelCopy(viewQuicksort) succeeded");
        } else {
            System.out.println("testRowLevelCopy(viewQuicksort) failed");
            passed = false;
        }

        if( testSort(viewQuicksort, "viewQuicksort") ) {
            System.out.println("testSort(viewQuicksort) succeeded");
        } else {
            System.out.println("testSort(viewQuicksort) failed");
            passed = false;
        }

        if( testDataLength() ) {
            System.out.println("testDataLength(after sortQuicksort) succeeded");
        } else {
            System.out.println("testDataLength(after sortQuicksort) failed");
            passed = false;
        }

        if( testDataOrder() ) {
            System.out.println("testDataOrder(after sortQuicksort) succeeded");
        } else {
            System.out.println("testDataOrder(after sortQuicksort) failed");
            passed = false;
        }

        // -----------------------------------------------------------------

        if( testCompareSorts(viewSelection, "viewSelection", viewQuicksort, "viewQuicksort") ) {
            System.out.println("testCompareSorts(viewSelection, viewQuicksort) succeeded");
        } else {
            System.out.println("testCompareSorts(viewSelection, viewQuicksort) failed");
            passed = false;
        }

        return passed;
    }

    // ---------------------------------------------------------------------
    /// The data has 100 records.  If the original classes table has the 
    /// wrong size at any point, this means that one of the sorts has 
    /// destroyed it.
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testDataLength() {
        // make sure that dataset has at least 100 entries
        if( classes.length != 100 ) {
            System.out.println("ERROR: data length too small");
            return false;
        } 
        return true;
    }

    // ---------------------------------------------------------------------
    /// This test verifies that a sort is performed on references to classes
    /// (shallow) and not on the values (deep).  A view is simply a 
    /// reordering of the rows and not a deep copy of the original classes 
    /// data.  Our data is just a snapshot at one point in time.  There 
    /// may be millions of users making changes at a fast pace and we 
    /// would like to resort the views with updated info from the classes 
    /// as this information is relatively sorted rather than have to 
    /// realloc over and over. 
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testDataOrder() {
        // make sure that classes ids remain in default classes id order
        for(int i = 0; i < classes.length; i++) {
            if( Integer.parseInt(classes[i][1]) != i+1 ) {
                System.out.println("ERROR: classes sequencing changed " + i + "," + 
                    classes[i][0] + "," + classes[i][1] + "," + classes[i][2]);
                return false;
            }
        }
        return true;
    }


    /// This test validates that an appropriate shallow copy (at the row
    /// level) has been performed when copying classes into view.  A view
    /// must have its own row array but each "row" in that array must be
    /// a unique pointer back to a class row.  There should be a one to one
    /// correspondence between view rows and class rows meaning for each
    /// class row, there should be one and only one reference to that row
    /// in the view array.
    /// @param classes the original classes array
    /// @param view a shallow row level copy in any order of classes
    /// @param vlabel the label we are using for the view array
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testRowLevelCopy(String[][] classes2, String[][] viewSelection2, String vlabel) {
        if(classes2.length != viewSelection2.length) {
            System.out.println("ERROR: classes length and " + vlabel + " length differ");
            return false;
        }

        if( classes2 == viewSelection2 ) {
            System.out.println("ERROR: classes2 and " + vlabel + " refer to same address.  " + vlabel + " is too shallow." );
            return false;
        }

        for(int i = 0; i < viewSelection2.length; i++) {
            if( viewSelection2[i].length != classes2[0].length ) {
               System.out.println("ERROR: row " + i + " in " + vlabel + " is malformed and has the wrong number of entries." );
               return false;
            }
        }

        for(int i = 0; i < classes2.length; i++) {
            int vi = -1;
            
            for(int j = 0; j < viewSelection2.length; j++) {
                if( viewSelection2[j][0] == classes2[i][0] ) {
                    if(viewSelection2[j] != classes2[i]) {
                        System.out.println("ERROR: row " + j + " in " + vlabel + " is not a reference.  " + vlabel + " is not a shallow copy of classes." );
                        return false;
                    }
                    vi = i;
                    break;
                }
            }
            if(vi == -1) {
               System.out.println("ERROR: row " + i + " in classes is missing from " + vlabel + "." );
               return false;
            }
        }



        return true;
    }

    // ---------------------------------------------------------------------
    /// Validates that the differential operation computes the correct value
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testDifferential() {
        String[] p = {"CSCI", "1112", "Algorithms and Data Structures", "07:30:00", "09:30:00"};  // AM differential
        String[] z = {"CSCI", "1112", "Algorithms and Data Structures", "10:30:00", "10:30:00"};  // Zero differential
        String[] n = {"CSCI", "1112", "Algorithms and Data Structures", "00:00:00", "23:59:00"};  // All Day differential

        if( ClassSchedule.differential(p) != 120 ) {
            return false;
        }
        if( ClassSchedule.differential(z) != 0 ) {
            return false;
        }
        if( ClassSchedule.differential(n) != 1439 ) {
            return false;
        }

        return true;
    }
    // ---------------------------------------------------------------------
    /// Validates that the less than operation operates correctly on the 
    /// virtual differential field
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testLessThan() {
        String[] p = {"CSCI", "1112", "Algorithms and Data Structures", "07:30:00", "09:30:00"};  // AM differential
        String[] z = {"CSCI", "1112", "Algorithms and Data Structures", "10:30:00", "10:30:00"};  // Zero differential
        String[] n = {"CSCI", "1112", "Algorithms and Data Structures", "00:00:00", "23:59:00"};  // All Day differential

        // - Positive against Zero tests -
        // left op should not be less than right op
        if( ClassSchedule.lessThan(p,z) ) {
            //System.out.println("Failed: p < z -> false");
            return false;
        }
        // left op should be less than right op
        if( !ClassSchedule.lessThan(z,p) ) {
            //System.out.println("Failed: z < p -> true");
            return false;
        }

        // - Positive against Positive tests -
        // left op should not be less than right op
        if( !ClassSchedule.lessThan(p,n) ) {
            //System.out.println("Failed: z < n -> false");
            return false;
        }
        // left op should be less than right op
        if( ClassSchedule.lessThan(n,p) ) {
            //System.out.println("Failed: n < z -> true");
            return false;
        }

        // - Equal to test -
        // left op should not be less than right op
        if( ClassSchedule.lessThan(p,p) ) {
            //System.out.println("Failed: z < z -> false");
            return false;
        }

        return true;
    }

    // ---------------------------------------------------------------------
    /// Validates that swap is referential (shallow)
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testSwap() {
        String[][] orig = {{"CSCI", "1112", "Algorithms and Data Structures", "07:30:00", "09:30:00"},
                            {"CSCI", "1113", "Algorithms and Data Structures", "07:30:00", "09:30:00"}};
        String[][] test = new String[2][];

        // copy the original references
        for(int i = 0; i < 2; i++) {
            test[i] = orig[i];
        }
    
        // perform the swap
        ClassSchedule.swapClasses(test, 0, 1);

        // follow the row references and verify that the values that are 
        // referenced are reversed
        if( Integer.parseInt(test[0][1]) != 1113 || Integer.parseInt(test[1][1]) != 1112 ) {
            return false;
        }

        // verify that the addresses of the swapped "rows" refer to the same 
        // original rows
        if( test[0] != orig[1] || test[1] != orig[0] ) {
            return false;
        }
        return true;
    }

    /// Validates that profile is valid and has the correct shape
    /// @param profile the profile to validate
    /// @param label the label of the profile
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testProfile( int[] profile, String label ) {
        if( profile == null) {
            System.out.println("ERROR: " + label + " is null");
            return false;
        }

        if( profile.length != 3 ) {
            System.out.println("ERROR: " + label + " has the wrong size");
            return false;
        }
        return true;
    }


    // ---------------------------------------------------------------------
    /// Validates that the selection sort method using a simple assumption 
    /// built into the classes file test data... 
    /// classes file test data was generted using randomization.  File was 
    /// tweaked to guarantee that no neighbor in classes should remain a 
    /// neighbor once sorted and that the same sequence will be generated 
    /// regardless of sort used.  
    /// @param view the view to validate
    /// @param label the label of the view
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testSort(String[][] viewSelection2, String label) {
        if( viewSelection2 == null ) {
            System.out.println("ERROR: " + label + " is null");
            return false; 
        }

        if( viewSelection2.length != classes.length ) {
            System.out.println("ERROR: " + label + " has the wrong size");
            return false;
        }

        return true;
    }

    // ---------------------------------------------------------------------
    /// Validates that the two sorts produce the same sorted output
    /// classes file test data was generted using randomization.  File was 
    /// tweaked to guarantee that no neighbor in classes should remain a 
    /// neighbor once sorted and that the same sequence will be generated 
    /// regardless of sort used.
    /// @param view1 one view to compare
    /// @param view2 a second view to compare
    /// @param label1 the label for view1
    /// @param label2 the label for view2
    /// @return true if test passes; otherwise, false if test fails
    public static boolean testCompareSorts(String[][] viewSort1, String label1, String[][] viewSort2, String label2) {
        if( viewSort1 == null ) {
            System.out.println("ERROR: " + label1 + " is null");
            return false; 
        }

        if( viewSort2 == null ) {
            System.out.println("ERROR: " + label2 + " is null");
            return false; 
        }

        if( viewSort1.length != viewSort2.length ) {
            System.out.println("ERROR: view lengths for testCompareSorts(" + label1 + ", " + label2 + ") do not match");
            return false;
        }

        // test data should ensure that regardless of sort the sorted data 
        // will have the same order.  This compares the ids in two views and
        // verifies that they are the same
        boolean result = true;
        for(int i = 0; i < viewSort1.length; i++) {
            if(viewSort1[i][1] != viewSort2[i][1] && (ClassSchedule.differential(viewSort1[i]) != ClassSchedule.differential(viewSort2[i]))) {
                // System.out.println("i: " + i + ", id: " + viewSort1[i][1] + ", delta: " + ClassSchedule.differential(viewSort1[i]));
                // System.out.println("i: " + i + ", id: " + viewSort2[i][1] + ", delta: " + ClassSchedule.differential(viewSort2[i]));
                // System.out.println("i: " + i + ", id1: " + view1[i][0] + ", id2: " + view2[i][0]);
                result = false;
            }
        }

        return result;

        // Note: this test is designed to delay return until sampling all 
        // data so that we can see all matches.
    }

}
